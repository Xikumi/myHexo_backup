---
title: 常见面试题
categories: 随笔    #分类
tags: 面试题          #标签
toc: true  #是否启用内容索引
---

### js中const，var，let区别与用法

1.const定义的变量不可以修改，而且必须初始化。

2.var定义的变量可以修改，如果不初始化会输出undefined，不会报错。

3.let是块级作用域，函数内部使用let定义后，对函数外部无影响。



### **trim函数**

trim()删除文本中除单词间的单个空格之外的所有空格



### window.confirm()

window.confirm()方法用于显示一个带有指定消息和确认及取消按钮的对话框。

如果访问者点击"确定"，此方法返回true，否则返回false。

### js的unshift() 方法

unshift() 可向数组的开头添加一个或更多元素，并返回新的长度。



**String、StringBuffer、StringBuilder的区别**

String是由final修饰，一旦被创建便不可更改，而StringBuilder和StringBuffer是可变的。

对于StringBuffer和StringBuilder来说区别不大，StringBuffer在方法上用synchronized修饰，是线程安全的，而StringBuilder是线程不安全的。

**HashMap的实现原理？什么场景下使用HashMap、LinkedHashMap、ConcurrentHashMap、WeakHashMap?哪些是线程安全的？**

hashMap的存储结构是由数组加链表/红黑树组成，采用Entry数组来存储key-value对，Entry类又是链表结构。根据key值通过哈希算法获取哈希值确定数组存储的位置，同一个哈希值下挂着链表，当链表的数量超过8时，链表转换成红黑树存储。

HashMap是以键值形式对存储对象，线程不安全且无序。在对顺序没有要求且单线程下使用。

LinkedHashMap的键值有序，但线程不安全。在单线程下对顺序有要求的场景使用。

ConcurrentHashMap是线程安全的Map，在多线程环境下使用。

WeakHashMap是线程不安全的，是基于弱引用，其对象可能随时被回收，适用于缓存的场景。

**synchronized和lock锁机制的异同**

异：

1. synchronized可以加在方法上，也可以加在特定代码块上；lock需要显示地指定起始位置和终止位置。
2. synchronized是由JVM执行的；而lock的锁定是通过代码实现的，他有比synchronized更精确的线程语义和更好的性能。
3. synchronized获取锁和释放锁的方式都是在块结构中，当获取多个锁时，必须以相反的顺序释放，而且是自动解锁。而lock则需要开发人员手动释放锁，并且必须在finally中释放，否则会引起死锁。

同：

lock能完成synchronized所实现的所有功能。

**JVM加载Class文件的原理机制？**

双亲委派机制：一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，只有父类加载器无法加载该类时，才会尝试从自己的类路径中加载该类。所以一个类在进行加载时，总是会先加载超类Object。

**JVM的内存结构及GC的工作原理？**

在JDK8中，JVM被划分成五个区域：堆、方法区、虚拟机栈、本地方法栈、程序计数器。

GC即为垃圾收集器。JVM中将对象的引用分为了四种类型，不同的对象引用类型GC会采用不同的方法进行回收：
（1）强引用：默认情况下，对象采用的均为强引用（GC不会回收）
（2）软引用：软引用是Java中提供的一种比较适合于缓存场景的应用（只有在内存不够用的情况下才会被GC）
（3）弱引用：在GC时一定会被GC回收
（4）虚引用：在GC时一定会被GC回收

**springMVC的实现原理？核心是什么？请求流程怎么处理？控制反转是怎么实现的？**

请求处理流程：

1. 客户端请求交给前端控制器；
2. 前端控制器根据请求信息调用处理器映射器；
3. 处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器并返回给前端控制器；
4. 前端控制器调用处理器适配器；
5. 处理器适配器调用合适的后端控制器 ；
6. 后端控制器执行完成返回ModelAndView ；
7. 前端控制器将ModelAndView传给视图解析器，解析后返回view；
8. 前端控制器进行视图渲染并响应用户；

五大核心组件：

　1.DispatcherServlet　　请求入口

　2.HandlerMapping　　  请求派发,负责请求和控制器建立一一对应的关系

　3.Controller　　　　　  处理器

　4.ModelAndView　　　  封装模型信息和视图信息

　5.ViewResolver　　　　视图处理器,定位页面

控制反转：

我们每次使用spring框架都要配置xml文件，这个xml配置了bean的id和class。

spring中默认的bean为单实例模式，通过bean的class引用反射机制可以创建这个实例。

因此，spring框架通过反射替我们创建好了实例并且替我们维护他们。

A需要引用B类，spring框架就会通过xml把B实例的引用传给了A的成员变量。

**从在浏览器地址中输入域名到数据返回发生了什么？**

1. 应用层DNS解析域名
2. 应用层客户端发送HTTP请求
3. 传输层TCP传输报文
4. 网络层IP协议查询MAC地址
5. 数据到达数据链路层
6. 服务器接收数据
7. 服务器处理请求
8. 服务器返回相应文件

解释三次握手，四次挥手以及为什么需要三次握手，四次挥手？

三次握手：

1. 客户端请求建立连接：SYN=1，seq=x；
2. 服务器对客户端的请求进行响应：SYN=1，ACK=1，seq=y，ack=x+1；
3. 客户端对服务器端的响应信息进行回应：ACK=1，seq=x+1，ack=y+1

四次挥手：

1. 客户端请求断开连接： FIN=1，seq = u；
2. 服务端对客户端的请求应答：ACK=1，seq=v，ack=u+1；
3. 服务端请求断开连接：FIN=1，ACK=1，seq=w，ack=u+1；
4. 客户端对服务端的请求应答：ACK=1，seq=u+1，ack=w+1





TCP的核心思想是既要保证数据的可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求。

TCP连接握手，握的是什么？	

是通信双方数据远点的序列号！

双方都需要确认对方收到了自己的序列号！



**什么是线程和进程，有什么区别？**

进程是系统中正在运行的一个程序，程序一旦运行就是进程。

线程是进程的一个实体，是进程的一条执行路径。

一个进程可以拥有多个线程，每个线程使用其所属进程的栈空间

主要区别：

1. 不同进程间数据很难共享，同一进程下不同线程间数据很易共享
2. 进程要比线程消耗更多的计算机资源
3. 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉
4. 调度和切换：线程上下文切换比进程上下文切换快得多
5. 在多线程OS中，进程不是一个可执行的实体
6. 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。－"互斥锁"
7. 进程使用的内存地址可以限定使用量。－“信号量”

**线程间常用的通信方法？**

1. 使用volatile关键字
2. 使用Object类的wait() 和 notify() 方法
3. 使用JUC工具类 CountDownLatch
4. 使用 ReentrantLock 结合 Condition
5. 基本LockSupport实现线程间的阻塞和唤醒

**JDBC使用步骤**

1. 加载数据库驱动
2. 通过DriverManager获取数据库连接
3. 通过Connection对象创建Statement对象
4. 使用Statement执行SQL语句
5. 操作ResultSet结果集
6. 回收数据库资源，包括关闭ResultSet、Statement和Connection等资源

**JDBC的Statement、PerparStatement、CallableStatement的区别？**

Statement只允许执行写死的SQL语句；

PerparStatement可以允许执行带占位符的SQL语句，能有效防止SQL注入；

CallableStatement是用于调用存储过程；

**数据库隔离级别？各自含义？mysql的默认隔离级别？**

1. Read Uncommit (读未提交)		脏读，不可重复读，幻读都不能避免
2. Read commit (读已提交)                能避免脏读，不能避免不可重复读，幻读
3. Repeatable Read (可重复读)          能避免脏读，不可重复读，不能避免幻读
4. Serialzable (可串行化)                     能避免脏读，不可重复读，幻读

MySQL默认的存储引擎InnoDB默认的隔离级别为Repeatable Read (可重复读 )，而且InnoDB实现的Repeatable Read避免了幻读。

**数据库索引的实现原理？什么情况下索引会失效？**

索引是使用B+树实现的数据结构。索引的思想就是，根据表中的某个属性建立一套算法，每次查询的时候，在内存中根据该算法得到出所需要的数据的物理地址，根据物理地址直接去磁盘中拿到结果数据，不用将表中的所有数据都加载到内存扫描一遍。这有点类似于，我们查字典的时候，根据偏旁部首等信息对一个汉字进行页码定位（这个过程可以看做是索引的算法执行的过程），查到一个汉字的页码，根据该页码直接找到汉字所在的页，不需要把整个字典翻一遍。

索引失效的情况：

1. 如果条件中有or，即使其中有条件带索引也不会使用；
2. .对于多列索引，不是使用的第一部分，则不会使用索引；
3. like查询是以%开头，索引会失效；
4. 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引
5. 如果mysql估计使用全表扫描要比使用索引快,则不使用索引

**对java8中Stream API的理解？**

Stream 流是Java8中处理集合的关键抽象概念，它可以对集合进行非常复杂的查找、过滤、筛选等操作，在新版的JPA中，也已经加入了Stream。

Stream API的特点：

1. Stream API的使用和同样是java8新特性的lambda表达式密不可分，可以大大提高编码效率和代码可读性。
2. Stream API提供串行和并行两种操作，其中并行操作能发挥多核处理器的优势，使用fork/join的方式进行并行操作以提高运行速度。
3. Stream API进行并行操作无需编写多线程代码即可写出高效的并发程序，且通常可避免多线程代码出错的问题。

**java8中函数式接口的用途是什么？**

函数式接口也叫功能性接口，用来特指某类型接口，为Java 中Lambda的实现而定义。在lambda的实现过程中，java选择接口作为Lambda表达式的目标类型，有函数式接口就可以接受Lambda表达式作为函数式接口的实现，更多是为了简化代码。

**Stream流中间操作之map和flatMap的区别？**

从源码上看出：

map函数式接口抽象方法的返回值是R，flatMap函数式接口抽象方法返回值是Stream< R >

所以flatMap作用就是将返回的Stream< R >拆开，再组合每个值成新的Stream< R >，

即map只是一维 1对1 的映射，而flatmap可以将一个2维的集合映射成一个一维,相当于他映射的深度比map深了一层 

**常见的数据结构？常见的算法？**

线性表，链表，队列，栈，二叉树，图

递归算法，常见排序算法，分治法，贪心算法，动态规划算法

冒泡排序

交换排序

快速排序

希尔排序

